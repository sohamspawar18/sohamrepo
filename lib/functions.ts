'use client'

// Auto-generated by ShaniAI
// Minimal viem-based helpers and dynamic wrappers for your contract
import { createPublicClient, http } from 'viem'
import { sepolia } from 'viem/chains'
import { getWalletClient } from './wallet'

export const CONTRACT_ABI = [
  {
    "type": "function",
    "stateMutability": "view",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ]
  },
  {
    "type": "function",
    "stateMutability": "view",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ]
  },
  {
    "type": "function",
    "stateMutability": "view",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ]
  },
  {
    "type": "function",
    "stateMutability": "view",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ]
  },
  {
    "type": "function",
    "stateMutability": "view",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ]
  },
  {
    "type": "function",
    "stateMutability": "nonpayable",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address"
      },
      {
        "name": "amount",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ]
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false
      }
    ],
    "anonymous": false
  }
] as const;
export const CONTRACT_ADDRESS = "0x88d021C5979a461e607d14Ff9eECAB530781D99D" as const;

// Prefer keyed RPCs to avoid public endpoint timeouts
const RPC_URL = (
  process.env.NEXT_PUBLIC_RPC_URL ||
  (process.env.NEXT_PUBLIC_ALCHEMY_API_KEY && ('https://eth-sepolia.g.alchemy.com/v2/' + process.env.NEXT_PUBLIC_ALCHEMY_API_KEY)) ||
  (process.env.NEXT_PUBLIC_INFURA_API_KEY && ('https://sepolia.infura.io/v3/' + process.env.NEXT_PUBLIC_INFURA_API_KEY)) ||
  'https://rpc.sepolia.org'
);
let __client: ReturnType<typeof createPublicClient> | undefined;
export function getPublicClient() {
  if (!__client) {
    __client = createPublicClient({ chain: sepolia, transport: http(RPC_URL, { timeout: 30000 }) });
  }
  return __client;
}

export function getFunctionsMeta() {
  const fns = (CONTRACT_ABI as unknown as any[]).filter((x) => x?.type === 'function');
  const reads = fns.filter((f) => f.stateMutability === 'view' || f.stateMutability === 'pure');
  const writes = fns.filter((f) => !(f.stateMutability === 'view' || f.stateMutability === 'pure'));
  return { reads, writes };
}

export async function callRead(functionName: string, args: any[] = []) {
  if (!CONTRACT_ADDRESS) throw new Error('No contract address set');
  const client = getPublicClient();
  return client.readContract({ address: CONTRACT_ADDRESS as any, abi: CONTRACT_ABI as any, functionName: functionName as any, args });
}

export async function callWrite(functionName: string, args: any[] = []) {
  if (!CONTRACT_ADDRESS) throw new Error('No contract address set');
  const wallet = await getWalletClient();
  const hash = await (wallet as any).writeContract({ address: CONTRACT_ADDRESS as any, abi: CONTRACT_ABI as any, functionName: functionName as any, args });
  const receipt = await getPublicClient().waitForTransactionReceipt({ hash });
  return receipt;
}

export function coerceArg(type: string, raw: string) {
  if (type.startsWith('uint') || type.startsWith('int')) {
    return BigInt(raw);
  }
  if (type === 'bool') {
    return raw === 'true' || raw === '1' || raw === 'on';
  }
  if (type.endsWith(']')) return JSON.parse(raw);
  return raw;
}
